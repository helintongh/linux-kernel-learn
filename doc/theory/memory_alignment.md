# 内存对齐

内存对齐作用是提高内存的访问效率。比如intel 32位cpu，每个总线周期都是从偶地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据，因此需要在内存中存放数据时进行对齐。

通常内存对齐很多时候都是说struct结构体的内存对齐，比如下面的结构体:

```c
struct A {
    char a;
    int b;
    short c;
};
```

无论在32位还是64位系统中，char占1字节，int占4字节，short占2字节。如果没有内存对齐，上述结构体占7字节。

```c
#include <stdio.h>

struct A{
    char a;
    int b;
    short c;
};
int main(){
    struct A a;
    printf("A: %ld\n", sizeof(a));
    return 0;
}
```

上述代码输出为：`A: 12`。这是因为编译器在编译的时候进行了内存对齐。

非指定对齐大小的情况下：

1. 结构体的**起始地址**能够被其最宽的成员大小整除
2. 结构体每个成员相对于**起始位置的偏移**能够被其**自身大小整除**，如果不能则在**前一个成员后面**补充字节
3. 结构体总大小能够**被最宽的成员的大小**整除，如不能则在之后补充字节。
   
同时还有一个简便公式：

1. **前面的地址必须是后面地址的正数倍，不是则补齐**
2. **整个struct的地址必须是最大成员的整数倍**

上面的例子，默认对齐大小是4.

char 1字节，后面的int 4字节。不满足条件1，补充字节让char占4字节，此时char占的内存为4恰好等于int的大小乘1(`4 * 1`)。然后最后一个成员short类型占2字节满足为前面地址的正数倍(`2 * 4 = 8`)。此时结构体内存大小为10字节，不满足条件3，再补两位，最大的成员大小此时的3倍即为结构体内存大小(`4 * 3 = 12`)。

这样条件1，2，3都满足了。
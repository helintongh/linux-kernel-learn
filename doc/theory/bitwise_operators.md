# 位运算

位运算即对一个bit(位)进行操作。bit可以抽象为一个与非门，8个bit构成一个byte(字节)，bit已经是粒度最小的可操作单元了。

c语言提供了6中位运算符：

注: 规律为不溢出的情况的总结，如果高位进位且进位时该位的值是1。规律失效。

I实际上是`|`但是markdown语法打印不出来。

核心记住下图即可。

| 符号 | 名称     | 定义                                                                                                 | 规律                             |
| ---- | -------- | ---------------------------------------------------------------------------------------------------- | -------------------------------- |
| <<   | 按位左移 | 操作数每向左移一位，符号位后的最高位都将被移出，低位补零。(可能会溢出)                               | 左移a位，操作数变成原来的2^a倍   |
| >>   | 按位右移 | 操作数每向右移一位，低位的移位都将被移出，左端高位补0或1。如果数据的最高位是1则补1，最高位是0则补0。 | 右移b位，操作数变成原来的1/2^b倍 |
| ~    | 按位取反 | 将操作数的二进制按位取反。                                                                           | 0变1,1变0                        |
| &    | 按位与   | 两个操作数均为1时结果为1，其余情况结果为0                                                            | 全1为1，其余为0                  |
| I    | 按位或   | 两个操作数有一个为1结果为1，其余情况结果为0                                                          | 有1为1，其余为0                  |
| ^    | 按位异或 | 两个操作数有一个为1，另一个为0时结果为1，其余情况为0                                                 | 不同为1，相同为0                 |


## 左移运算(<<)

左移运算符`<<`用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补0。

看如下例子,b和d怎么被计算出来的呢？

```c
int a = 9;
int b = a << 3;
int c = -9;
int d = c << 3;
```

int是4字节，总共`4 * 8 = 32`bit(位)。

```
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001 (9在内存中的表示)
-----------------------------------------------------------------------------------
0000 0000 -- 0000 0000 -- 0000 0000 -- 0100 1000 (72 在内存中的存储)
```

b等于72。

-9的原码是
```
原码
1000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001
反码
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0110 (反码:正数与原码相同,负数原码取反)
补码
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111 (补码:正数与原码相同,负数反码取反来计算)
```

**计算机中所有值都是补码形式存在于内存。**

```
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111 (-9在内存中)
-----------------------------------------------------------------------------------
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 1000 (-72在内存中)
```

所以(-9)<<3的结果为-72。

**如果数据较小，被丢弃的高位不包含 1，那么左移 n 位相当于乘以 2 的 n 次方。**

## 右移运算(>>)

右移运算符>>用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。

**如果被丢弃的低位不包含 1，那么右移 n 位相当于除以 2 的 n 次方(但被移除的位中经常会包含 1)**

## 按位取反(~)

取反运算符~为单目运算符，右结合性，作用是对参与运算的二进制位取反。例如~1为0，~0为1，这和逻辑运算中的!非常类似。

把补码形式的数字按位取反即可。注意此时符号位也哟取反。

```c
#include <stdio.h>
int main(){
    printf("%d, %d\n", ~9, ~-9 );
    return 0;
}
// 输出为 -10, 8
```

## 按位与(&)

一个比特（Bit）位只有 0 和 1 两个取值，只有参与&运算的两个位都为 1 时，结果才为 1，否则为 0。例如1&1为 1，0&0为 0，1&0也为 0，这和逻辑运算符`&&`非常类似。

例如:`9 & 5`可以转换成如下的运算:

```
  0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （9 在内存中的存储）
& 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
-----------------------------------------------------------------------------------
  0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001  （1 在内存中的存储）
```

**按位与运算通常用来对某些位清 0，或者保留某些位。**例如要把 n 的高 16 位清 0 ，保留低 16 位，可以进行`n & 0XFFFF`运算（0XFFFF 在内存中的存储形式为 `0000 0000 -- 0000 0000 -- 1111 1111 -- 1111 1111`）。

```c
#include <stdio.h>
int main(){
    int n = 65537; // 其补码为 0000 0000 -- 0000 0001 -- 0000 0000 -- 0000 0001
    printf("%d, %d, %X\n", 9 & 5, -9 & 5, n & 0XFFFF);
    return 0;
}
// 代码输出:1, 5, 1
```

## 按位或(|)

参与|运算的两个二进制位有一个为 1 时，结果就为 1，两个都为 0 时结果才为 0。例如1|1为1，0|0为0，1|0为1，这和逻辑运算中的`||`非常类似。

例如，9 | 5可以转换成如下的运算：

```
    0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （9 在内存中的存储）
|   0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
-----------------------------------------------------------------------------------
    0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1101  （13 在内存中的存储）
```

**按位或运算可以用来将某些位置 1，或者保留某些位。**例如要把 n 的高 16 位置 1，保留低 16 位，可以进行`n | 0XFFFF0000`运算（0XFFFF0000 在内存中的存储形式为 1111 1111 -- 1111 1111 -- 0000 0000 -- 0000 0000）。

```c
#include <stdio.h>
int main(){
    int n = 0X2D; // 0000 0000 -- 0000 0000 -- 0000 0000 -- 0010 1101
    printf("%d, %d, %d\n", 9 | 5, -9 | 5, n | 0XFFFF0000);
    return 0;
}
// 输出为: 13, -9, -65491
```

```
    0000 0000 -- 0000 0000 -- 0000 0000 -- 0010 1101
|   1111 1111 -- 1111 1111 -- 0000 0000 -- 0000 0000
-----------------------------------------------------------------------------------
    1111 1111 -- 1111 1111 -- 0000 0000 -- 0010 1101 (-65491 在内存中的存储)
```


## 按位异或(^)

参与^运算两个二进制位不同时，结果为 1，相同时结果为 0。例如0^1为1，0^0为0，1^1为0。

例如，9 ^ 5可以转换成如下的运算：

```
  0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （9 在内存中的存储）
^ 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
-----------------------------------------------------------------------------------
  0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1100  （12 在内存中的存储）
```

9 ^ 5的结果为 12。

```c
#include <stdio.h>
int main(){
    unsigned n = 0X0A07002D;
    printf("%d, %d, %X\n", 9 ^ 5, -9 ^ 5, n ^ 0XFFFF0000);
    return 0;
}
// 输出为 12, 14, F5F8002D
```

## 位运算常用算法

1. 判断奇偶数

```c
#include <stdio.h>

int main()
{
  int n = 2;
  int c = n & 1;
  printf("%d\n" ,c);
  if (n & 1) {
    printf("It's odd number\n");
  }

  if (!(n & 1)) {
    printf("It's even number\n");
  }

  return 0;
}
// 输出为:It's even number
```

核心代码`n & 1`。

如果数字以二进制形式在内存中的话，只需要判断最后一位是1还是0，如果是1代表是奇数，如果是0代表是偶数。

2. 交换两个数

```c
#include <stdio.h>

int main()
{
  int x = 3;
  int y = 4;
  printf("before swap x,y x is: %d, y is: %d\n", x, y);

  x = x ^ y;
  y = x ^ y;
  x = x ^ y;

  printf("after swap x,y x is: %d, y is: %d\n", x, y);

  return 0;
}
/*
output:
before swap x,y x is: 3, y is: 4
after swap x,y x is: 4, y is: 3
*/
```

下面解释下代码:

两个相同的数异或(xor)之后的结构会等于0，即n ^ n = 0。并且任何数与0异或等于它本身，即n ^ 0 = n。

```c
  x = x ^ y; // 1;
  y = x ^ y; // 2;
  x = x ^ y; // 3;
```

把1;中的x带入2;，则`y = x ^ y;`为`y = (x ^ y) ^ y = x ^ (y ^ y) = x ^ 0 = x`

然后把1;和2;带入到3;中即为`x = x ^ y = x ^ y ^ x = x ^ x ^ y = y`

这样很明显完成了x和y的交换，这里要说明**异或运算支持交换律和结合律。**

3. 找出没有重复的数

给出一组整数，有一个数只出现了一次，其余都出现了两次。找出只出现了一次的数。

这种问题一般使用hash表来解决，此时时间复杂度是O(n),空间复杂度也为O(n)。但是异或可以做到时间复杂度为O(n)，空间复杂度为O(1)。

以如下数据为例子`1 2 3 4 5 1 2 3 4`。其中5只出现了一次，其余数字出现了两次，把它们全部异或。结果如下:

`1^2^3^4^5^1^2^3^4 = (1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5`。

```c
#include <stdio.h>

int find(int *arr, int length) {
  int tmp = *arr;
  for (int i = 1; i < length; i++) {
    tmp = tmp ^ *(arr + i);
  }
  return tmp;
}

int main()
{
  int arr[9] = {1, 2, 3, 4, 5, 1, 2, 3, 4};
  int ret = find(arr, 9);
  printf("%d\n", ret);
  return 0;
}
```

4. 3的n次方

普通的3的n次方实现

```c
int pow(int n) {
  int tmp = 1;
  for (int i = 1; i <= n; i++) {
    tmp *= 3;
  }
  return tmp;
}
```

而位运算怎么做呢？举个例子 n = 13,则n的二进制表示位1101,那么3的13次方可以转为：

3 ^ 1101 = 3 ^ 0001 * 3 ^ 0100 * 3 ^ 1000

可以通过 `& 1`和 `>>1` 来逐位读取 1101，为1时将该位代表的乘数累乘到最终结果。直接看代码吧，反而容易理解：

```c
#include <stdio.h>

int pow(int n) {
  int sum = 1;
  int tmp = 3;
  while (n != 0) {
    if (n & 1 == 1) {
      sum *= tmp;
    }
    tmp *= tmp;
    n = n >> 1;
  }

  return sum;
}

int main()
{
  int ret = pow(13);
  printf("%d\n", ret);
  return 0;
}
```

上述时间复杂度为O(logn)。

位运算很多情况下都是很二进制扯上关系的，所以我们要判断是否是否位运算，很多情况下都会把他们拆分成二进制，然后观察特性，或者就是利用与，或，异或的特性来观察。

位运算还可以节约内存。以上就是位运算的总结。
进程中不直接对物理地址进行操作
CPU在运行时 指定的地址通过MMU转换后才能访问到真正的物理内存
转换的过程分为分段和分页

分段机制简单来说:将进程的代码 数据 栈分在不同的虚拟地址段上，从而避免进程间的相互影响,分段之前的地址称为逻辑地址

它由两部分组成，高位的段选择符和低位的段内偏移

在分段时先用段选择符在相应的段描述表中找到段描述符(某一个段的基地址) + 段内偏移量 得到对应的线性地址(虚拟地址)

Linux 所有的段都指向相同的地址范围，段的基地址都为0,这样逻辑地址和线性地址在数值上就相同了。

重点:分页
即线性地址到物理地址的转换过程
为了兼容32位和64位
4级页表模型
PGD页全局目录,PUD页上级目录,PMD页中间目录,页表。

某些页表有可能未被使用。
对于没有启用物理地址扩展的32位系统，2级页表足够了。页上级目录索引和页中间目录索引这两位置为0.页目录在指针序列中仍保留了下来
寻址的过程中不能跳过页上级目录和页中间目录直接到页表。

64位硬件限制，地址线仅有48条。所以线性地址智能使用48位
4级页表。pgd，pud,pmd,page table分别9位，页内偏移12位。共48位，剩下的高位做保留用来扩展。页面大小都为4kb，每一个页表项位8bit
整个页表可映射的空间为256TB

新intel MMU规定可以进行5级页表管理。4.15内核pgd和pud之间新增了p4d页目录。这个目录还未被使用。CR3寄存器，保存pgd目录的地址。内核创建一个
进程就会为其创建页全局目录，task_struct结构中指向mm_struct结构指针mm，mm_struct就是用来描述进程虚拟地址空间的。字段PGD用来保存该进程的页全局目录的
(物理)地址的。进程切换过程中，os访问task_struct->mm_struct->PGD取得新进程的页全局目录的地址填充到CR3寄存器中就完成了页表的切换





